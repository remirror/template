/**
 * @script
 *
 * Generate configuration files for `sizeLimit` and package `tsconfig`'s.
 */

import chalk from 'chalk';
import path from 'path';
import writeJSON from 'write-json-file';

import {
  baseDir,
  formatFiles,
  getAllDependencies,
  getRelativePathFromJson,
  getTypedPackagesWithPath,
  Package,
} from './helpers';

// Get the args to see what needs to be generated.
const [, , ...args] = process.argv;

// Whether the runner should only update the tsconfig in the package.
const tsconfigPackagesOnly = args.includes('--ts-packages');
const experimentalReferences = args.includes('--ts-experimental-references');

// A collection of the absolute paths where files will be written to.
const paths = {
  sizeLimit: baseDir('support', 'root', '.size-limit.json'),
  mainTsconfig: baseDir('tsconfig.json'),
  baseTsconfig: baseDir('support', 'tsconfig.base.json'),
};

// A list of all the generated files which will be prettified at the end of the process.
const filesToPrettify: string[] = [];

/**
 * This generates the `.size-limit.json` file which is currently placed into the
 * `support/root` folder.
 */
async function generateSizeLimitConfig() {
  console.log(chalk`{blue Generating {bold.grey size-limit.json} config file}`);

  // Get all the packages in the `pnpm` monorepo.
  const packages = await getAllDependencies();

  // Transform the packages into the correct sizes.
  const sizes = packages
    // Only pick the packages that are ESModules and have a size limit value in the `meta` package.json field.
    .filter((pkg): pkg is Package & { module: string } => !!(pkg.module && pkg.meta?.sizeLimit))

    // Convert the package.json into a valid array of [sizelimit
    // config](https://github.com/ai/size-limit/blob/HEAD/README.md#config)
    .map((pkg) => {
      const relativePath =
        typeof pkg.browser === 'string'
          ? pkg.browser
          : pkg.browser?.[`./${pkg.module}`] || pkg.module;

      return {
        name: pkg.name,
        path: path.join(getRelativePathFromJson(pkg), relativePath),
        limit: pkg.meta?.sizeLimit,
        ignore: Object.keys(pkg.peerDependencies ?? {}),
        running: false,
      };
    });

  await writeJSON(paths.sizeLimit, sizes);
  filesToPrettify.push(paths.sizeLimit);
}

// The base tsconfig starting point.
const baseMainTsconfig = {
  __AUTO_GENERATED__: 'To update run: `pnpm generate:ts:experimental`',
  files: [],
  references: [
    { path: 'support/e2e/tsconfig.json' },
    { path: 'support/storybook/tsconfig.json' },
    { path: 'examples/with-next/tsconfig.json' },
    { path: 'support/tsconfig.all.json' },
  ],
};

// Store the name used for all tsconfig files.
const tsconfigFileName = 'tsconfig.json';

// Packages which should not be referenced in the main tsconfig reference file.
// These ones don't have a tsconfig available.
const excludedPackageNames = new Set(['@remirror/support']);

/**
 * Generate the main tsconfig reference file which points to all the packages.
 */
async function generateMainTsConfig() {
  console.log(
    chalk`{blue Generating {bold.grey tsconfig.json} reference file for the project root}`,
  );

  // Get all the workspace packages.
  const packages = await getAllDependencies();

  // The variable which will be updated with all the references from packages.
  const mainTsconfig = { ...baseMainTsconfig };

  // Loop through each package an add the relevant tsconfig files to the list of
  // reference.
  for (const pkg of packages) {
    if (excludedPackageNames.has(pkg.name)) {
      continue;
    }

    // Add the reference to the main tsconfig object.
    mainTsconfig.references.push({
      path: path.join(getRelativePathFromJson(pkg), tsconfigFileName),
    });
  }

  // Write the main tsconfig reference file to the defined absolute path.
  await writeJSON(paths.mainTsconfig, mainTsconfig);

  // Add the generated file to the list of files to prettify.
  filesToPrettify.push(paths.mainTsconfig);
}

const basePackageTsconfig = {
  // Flag to show that this file is autogenerated and should not be edited.
  __AUTO_GENERATED__: 'To update run: `pnpm generate:ts`',

  // Needs to be generated based on the location of the package.
  extends: '',
  compilerOptions: {},
};

/**
 * Generate a tsconfig for every package.
 */
async function generatePackageTsConfigs() {
  console.log(chalk`{blue Generating {bold.grey tsconfig.json} files for all packages}`);

  // Get the full package and the locations of all packages with a `types` field
  // in their `package.json`.
  const [packages, dependencies] = await Promise.all([
    getAllDependencies(),
    getTypedPackagesWithPath(),
  ]);

  /**
   * Write the file for an individual package.
   */
  async function writePackageTsconfig(pkg: Package) {
    /**
     * Collect all the references need for the current package.
     */
    // const references: Array<{ path: string }> = [];

    for (const dependency of Object.keys(pkg.dependencies ?? {})) {
      // Check if the dependency is one of the internal workspace dependencies.
      // We only want to add the internal project dependencies to the
      // references.
      if (!dependencies[dependency]) {
        continue;
      }

      // references.push({
      //   // Add the dependency which is a path relative to the current package being checked.
      //   path: join(relative(pkg.location, dependencies[dependency]), tsconfigFileName),
      // });
    }

    // Don't add a tsconfig to packages within the support directory.
    if (path.relative(baseDir(), pkg.location).startsWith('support')) {
      return;
    }

    // The path for the tsconfig
    const tsconfigFilePath = path.join(pkg.location, tsconfigFileName);

    // The compiler options for the tsconfig file. If this is a typed package
    // then it is declared to be composite and if not it is left quite bare.
    const tsconfigCompilerOptions = pkg.types
      ? { declaration: true, noEmit: true }
      : { noEmit: true };

    // Create the json for the tsconfig which will be written to the tsconfig file.
    const tsconfig = {
      ...basePackageTsconfig,
      extends: path.relative(pkg.location, baseDir(paths.mainTsconfig)),
      compilerOptions: {
        ...basePackageTsconfig.compilerOptions,
        ...tsconfigCompilerOptions,
      },
      // references,
    };

    // Write and prettify the files.
    await writeJSON(tsconfigFilePath, tsconfig);

    // Add the file created to the list of files to prettify at the end of the
    // script being run.
    filesToPrettify.push(tsconfigFilePath);
  }

  // Write all the files to the locations.
  await Promise.all(packages.map(writePackageTsconfig));
}

/**
 * The runner that runs when this is actioned.
 */
async function main() {
  if (experimentalReferences) {
    // Run when flag `--ts-experimental-references` is used. It currently breaks
    // everything but might become useful in the future.
    await Promise.all([generatePackageTsConfigs(), generateMainTsConfig()]);
  } else if (tsconfigPackagesOnly) {
    // Run when flag `--ts-packages` is used.
    await Promise.all([generatePackageTsConfigs()]);
  } else {
    // This is the default mode to run.
    await Promise.all([generateSizeLimitConfig()]);
  }

  if (filesToPrettify.length === 0) {
    return;
  }

  // Format all the files which have been created before exiting.
  await formatFiles(filesToPrettify.join(' '), { silent: true, formatter: 'prettier' });
}

// Run the script and listen for any errors.
main().catch((error) => {
  console.log(
    chalk`{red Something went wrong while running the} {blue.bold playground:imports} {red script.}`,
  );

  console.error(error);
  process.exit(1);
});
